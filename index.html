<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Graph Editor beta 0.1</title>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/2.6.3/svg.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
    <script type="text/javascript"
            src="https://cdnjs.cloudflare.com/ajax/libs/svg.draggy.js/1.1.1/svg.draggy.min.js"></script>
    <script type="text/javascript" src="plugins/connectable/svg.connectable.js"></script>
</head>
<style>
    .content {
        border: 1px solid black;
        padding: 10px;
    }
</style>
<body>
<h2>Graph Editor beta 0.1</h2>
<!--<div>-->
<!--    <div>-->
<!--        <input id="state-option" type="radio" name="mode" value="state">-->
<!--        <label for="state-option">Состояние</label>-->
<!--    </div>-->
<!--    <div>-->
<!--        <input id="work-option" type="radio" name="mode" value="word">-->
<!--        <label for="work-option">Работа</label>-->
<!--    </div>-->
<!--</div>-->

<div class="content" oncontextmenu="return false;">
    <svg id="stage"></svg>
</div>
<button id="validation-btn">Validation</button>
<script>
    var counter = -1;

    var candidateNode = null;
    var works = [];

    const nodeColor = '#C2185B';

    var svg = SVG('stage').size("100%", 900);
    var nodes = svg.group();

    svg.dblclick(function (evt) {
        let e = evt.target;
        let dim = e.getBoundingClientRect();

        let x = evt.clientX - dim.left;

        let y = evt.clientY - dim.top;

        let currentNodeNumber = ++counter;
        var node = nodes.group().translate(x, y).draggy();
        node.circle(70)
            .fill(nodeColor)
            .opacity(0.8);

        node.on('contextmenu', function () {
            let nodeNumber = $(this.node).find('text').html();
            this.remove();
            works = $.grep(works, function (work) {
                if (work.source == nodeNumber || work.target == nodeNumber) {
                    $('#' + work.id).remove();
                    return false;
                } else {
                    return true;
                }
            });

            works.forEach(function (work) {
                    if (work.source > nodeNumber) {
                        work.source--;
                    }
                    if (work.target > nodeNumber) {
                        work.target--;
                    }
                }
            );

            $('.node-number').each(function () {
                let currentValue = $(this).html();
                if (nodeNumber < currentValue) {
                    $(this).html(--currentValue)
                }
            });
            counter--;
        });

        node.plain(currentNodeNumber)
            .attr("class", "node-number")
            .font({fill: '#000000', family: 'Inconsolata'});
        node.click(function (evt) {
            if (candidateNode === this) {
                this.children()[0].fill({color: nodeColor});
                candidateNode = null;
            } else if (candidateNode) {

                let currentValue = this.children()[1].node.textContent;
                let previousValue = candidateNode.children()[1].node.textContent;

                if (currentValue < previousValue) {
                    alert("Переход из большего в меньшее не возможен!")
                } else {
                    let connectable = candidateNode.connectable({
                        marker: 'default',
                        targetAttach: 'perifery',
                        sourceAttach: 'perifery',
                        color: '#2a88c9'
                    }, this);

                    let connectorId = $(connectable.connector.node).attr("id");
                    works.push(
                        {
                            id: connectorId,
                            source: previousValue,
                            target: currentValue
                        }
                    );

                    this.children()[0].fill({color: nodeColor});
                    candidateNode.children()[0].fill({color: nodeColor});
                    candidateNode = null;
                }
            } else {
                candidateNode = this;
                candidateNode.children()[0].fill({color: '#b4ff47'})
            }
        });
    });

    $("div.content>svg>g").on('contextmenu', 'path', function (e) {
        let connectorId = $(this).attr("id");
        works = $.grep(works, function (work) {
            return work.id !== connectorId;
        });
        $(this).remove();
    });


    $("#validation-btn").click(function (e) {
        var states = [];
        for (let i = 0; i <= counter; i++) {
            let previous = [];
            let next = [];
            works.forEach(function (work) {
                if (i == work.target) {
                    previous.push(work.source);
                }
                if (i == work.source) {
                    next.push(work.target);
                }
            });

            states.push(
                {
                    id: i,
                    prev: previous,
                    next: next
                }
            )
        }

        states.forEach(function (state) {
            if (state.id == 0 && (state.prev.length > 0 || state.next.length == 0)){
                alert("Состояние 0 не начальное!");
            }

            if (state.id == counter && (state.next.length > 0 || state.prev.length == 0)) {
                alert("Состояние " + counter + " не конечное!");
            }

            if (state.id > 0 && state.id < counter && (state.next.length == 0 || state.prev.length == 0)) {
                alert("Состояние " + state.id + " не промежуточное!")
            }
        });
    });
</script>
</body>
</html>